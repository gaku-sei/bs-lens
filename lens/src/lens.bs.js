// Generated by BUCKLESCRIPT VERSION 4.0.18, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Hashtbl = require("bs-platform/lib/js/hashtbl.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function modify(l, f, a) {
  var value = Curry._1(l[/* get */0], a);
  var new_value = Curry._1(f, value);
  return Curry._2(l[/* set */1], new_value, a);
}

function _get(a, l) {
  return Curry._1(l[/* get */0], a);
}

function compose(l1, l2) {
  var partial_arg = l1[/* get */0];
  var partial_arg$1 = l2[/* get */0];
  var partial_arg$2 = l1[/* set */1];
  return /* record */[
          /* get */(function (param) {
              return Curry._1(partial_arg, Curry._1(partial_arg$1, param));
            }),
          /* set */(function (param) {
              var partial_arg$3 = Curry._1(partial_arg$2, param);
              return (function (param) {
                  return modify(l2, partial_arg$3, param);
                });
            })
        ];
}

function pair(l1, l2) {
  return /* record */[
          /* get */(function (param) {
              return /* tuple */[
                      Curry._1(l1[/* get */0], param[0]),
                      Curry._1(l2[/* get */0], param[1])
                    ];
            }),
          /* set */(function (param, param$1) {
              return /* tuple */[
                      Curry._2(l1[/* set */1], param[0], param$1[0]),
                      Curry._2(l2[/* set */1], param[1], param$1[1])
                    ];
            })
        ];
}

function pair3(l1, l2, l3) {
  return /* record */[
          /* get */(function (param) {
              return /* tuple */[
                      Curry._1(l1[/* get */0], param[0]),
                      Curry._1(l2[/* get */0], param[1]),
                      Curry._1(l3[/* get */0], param[2])
                    ];
            }),
          /* set */(function (param, param$1) {
              return /* tuple */[
                      Curry._2(l1[/* set */1], param[0], param$1[0]),
                      Curry._2(l2[/* set */1], param[1], param$1[1]),
                      Curry._2(l3[/* set */1], param[2], param$1[2])
                    ];
            })
        ];
}

function cond(pred, lt, lf) {
  var choose = function (a) {
    if (Curry._1(pred, a)) {
      return lt;
    } else {
      return lf;
    }
  };
  return /* record */[
          /* get */(function (a) {
              var l = choose(a);
              return Curry._1(l[/* get */0], a);
            }),
          /* set */(function (b, a) {
              var l = choose(a);
              return Curry._2(l[/* set */1], b, a);
            })
        ];
}

function get_state(l, a) {
  return /* tuple */[
          Curry._1(l[/* get */0], a),
          a
        ];
}

function put_state(l, v, a) {
  return /* tuple */[
          /* () */0,
          Curry._2(l[/* set */1], v, a)
        ];
}

function modify_state(l, f, a) {
  return /* tuple */[
          /* () */0,
          modify(l, f, a)
        ];
}

function ignore_000(prim) {
  return /* () */0;
}

function ignore_001(param, a) {
  return a;
}

var ignore = /* record */[
  ignore_000,
  ignore_001
];

function id_000(a) {
  return a;
}

function id_001(b, param) {
  return b;
}

var id = /* record */[
  id_000,
  id_001
];

function first_000(prim) {
  return prim[0];
}

function first_001(v, a) {
  return /* tuple */[
          v,
          a[1]
        ];
}

var first = /* record */[
  first_000,
  first_001
];

function second_000(prim) {
  return prim[1];
}

function second_001(v, a) {
  return /* tuple */[
          a[0],
          v
        ];
}

var second = /* record */[
  second_000,
  second_001
];

function head_001(v, xs) {
  return /* :: */[
          v,
          List.tl(xs)
        ];
}

var head = /* record */[
  /* get */List.hd,
  head_001
];

function tail_001(v, xs) {
  return /* :: */[
          List.hd(xs),
          v
        ];
}

var tail = /* record */[
  /* get */List.tl,
  tail_001
];

function for_hash(key) {
  return /* record */[
          /* get */(function (h) {
              try {
                return Caml_option.some(Hashtbl.find(h, key));
              }
              catch (exn){
                if (exn === Caml_builtin_exceptions.not_found) {
                  return undefined;
                } else {
                  throw exn;
                }
              }
            }),
          /* set */(function (v, h) {
              if (v !== undefined) {
                Hashtbl.add(h, key, Caml_option.valFromOption(v));
                return h;
              } else {
                Hashtbl.remove(h, key);
                return h;
              }
            })
        ];
}

function for_assoc(key) {
  return /* record */[
          /* get */(function (l) {
              try {
                return Caml_option.some(List.assoc(key, l));
              }
              catch (exn){
                if (exn === Caml_builtin_exceptions.not_found) {
                  return undefined;
                } else {
                  throw exn;
                }
              }
            }),
          /* set */(function (v, l) {
              if (v !== undefined) {
                var l$prime = List.remove_assoc(key, l);
                return /* :: */[
                        /* tuple */[
                          key,
                          Caml_option.valFromOption(v)
                        ],
                        l$prime
                      ];
              } else {
                return List.remove_assoc(key, l);
              }
            })
        ];
}

function for_array(i) {
  return /* record */[
          /* get */(function (a) {
              return Caml_array.caml_array_get(a, i);
            }),
          /* set */(function (v, a) {
              var a$prime = $$Array.copy(a);
              Caml_array.caml_array_set(a$prime, i, v);
              return a$prime;
            })
        ];
}

function for_list(i) {
  return /* record */[
          /* get */(function (xs) {
              return List.nth(xs, i);
            }),
          /* set */(function (v, xs) {
              return List.rev(List.fold_left((function (param, x) {
                                  var j = param[1];
                                  var xs$prime = param[0];
                                  return /* tuple */[
                                          i === j ? /* :: */[
                                              v,
                                              xs$prime
                                            ] : /* :: */[
                                              x,
                                              xs$prime
                                            ],
                                          j + 1 | 0
                                        ];
                                }), /* tuple */[
                                /* [] */0,
                                0
                              ], xs)[0]);
            })
        ];
}

function option_get_000(param) {
  if (param !== undefined) {
    return Caml_option.valFromOption(param);
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function option_get_001(v, param) {
  return Caml_option.some(v);
}

var option_get = /* record */[
  option_get_000,
  option_get_001
];

function list_map(l) {
  var partial_arg = l[/* get */0];
  var partial_arg$1 = l[/* set */1];
  return /* record */[
          /* get */(function (param) {
              return List.map(partial_arg, param);
            }),
          /* set */(function (param, param$1) {
              return List.map2(partial_arg$1, param, param$1);
            })
        ];
}

function xmap(f, g, l) {
  var partial_arg = l[/* get */0];
  var partial_arg$1 = l[/* set */1];
  return /* record */[
          /* get */(function (param) {
              return Curry._1(f, Curry._1(partial_arg, param));
            }),
          /* set */(function (param) {
              return Curry._1(partial_arg$1, Curry._1(g, param));
            })
        ];
}

function $caret$eq(l, v, a) {
  return Curry._2(l[/* set */1], v, a);
}

function $pipe$neg$neg(l1, l2) {
  return compose(l2, l1);
}

var $star$star$star = pair;

function $plus$eq(l, v) {
  return (function (param) {
      return modify(l, (function (param) {
                    return v + param | 0;
                  }), param);
    });
}

function $neg$eq(l, v) {
  var partial_arg = -v | 0;
  var partial_arg$1 = function (param) {
    return partial_arg + param | 0;
  };
  return (function (param) {
      return modify(l, partial_arg$1, param);
    });
}

var Infix = /* module */[
  /* %^ */_get,
  /* ^= */$caret$eq,
  /* ^%= */modify,
  /* |-- */$pipe$neg$neg,
  /* --| */compose,
  /* *** */$star$star$star,
  /* += */$plus$eq,
  /* -= */$neg$eq
];

function $caret$eq$bang(l, v) {
  return (function (param) {
      return put_state(l, v, param);
    });
}

function $plus$eq$bang(l, v) {
  return (function (param) {
      return modify_state(l, (function (param) {
                    return v + param | 0;
                  }), param);
    });
}

function $neg$eq$bang(l, v) {
  var partial_arg = -v | 0;
  var partial_arg$1 = function (param) {
    return partial_arg + param | 0;
  };
  return (function (param) {
      return modify_state(l, partial_arg$1, param);
    });
}

function $at$eq$bang(l, v) {
  return (function (param) {
      return modify_state(l, (function (a) {
                    return Pervasives.$at(a, v);
                  }), param);
    });
}

var StateInfix = /* module */[
  /* ^=! */$caret$eq$bang,
  /* +=! */$plus$eq$bang,
  /* -=! */$neg$eq$bang,
  /* @=! */$at$eq$bang
];

exports.modify = modify;
exports.compose = compose;
exports.pair = pair;
exports.pair3 = pair3;
exports.cond = cond;
exports.get_state = get_state;
exports.put_state = put_state;
exports.modify_state = modify_state;
exports.ignore = ignore;
exports.id = id;
exports.first = first;
exports.second = second;
exports.head = head;
exports.tail = tail;
exports.for_hash = for_hash;
exports.for_assoc = for_assoc;
exports.for_array = for_array;
exports.for_list = for_list;
exports.option_get = option_get;
exports.list_map = list_map;
exports.xmap = xmap;
exports.Infix = Infix;
exports.StateInfix = StateInfix;
/* No side effect */
